#!/usr/bin/env python3
"""
MCP 配置文档同步检查脚本。

检查范围：
1. 白名单文档的 mcp_config_snippet 受控块是否与 SSOT 同步。
2. 非白名单文档中是否存在包含 "mcpServers" 的代码块（禁止）。
3. docs/gateway/02_mcp_integration_cursor.md 中默认 server 与 --server 示例一致且为 engram。
"""

from __future__ import annotations

import argparse
import json
import re
import sys
from dataclasses import dataclass, field
from pathlib import Path

SSOT_PATH = Path("configs/mcp/.mcp.json.example")
DOC_ALLOWLIST = [
    Path("README.md"),
    Path("docs/installation.md"),
    Path("docs/gateway/02_mcp_integration_cursor.md"),
]

BEGIN_MARKER = "<!-- BEGIN GENERATED: mcp_config_snippet -->"
END_MARKER = "<!-- END GENERATED -->"
AUTO_COMMENT = "<!-- AUTO-GENERATED BY render_mcp_config_snippet.py; DO NOT EDIT -->"

CODE_FENCE_PATTERN = re.compile(r"```[^\n]*\n(.*?)\n```", re.DOTALL)

DEFAULT_SERVER_NAME = "engram"
SERVER_EXAMPLE_PATTERN = re.compile(r"--server\s+engram")
DEFAULT_SERVER_PATTERN = re.compile(r"默认\s*server.*engram", re.IGNORECASE)


@dataclass
class SyncError:
    code: str
    message: str
    file: str
    hint: str = ""


@dataclass
class SyncResult:
    ok: bool = True
    errors: list[SyncError] = field(default_factory=list)
    checked_docs: list[str] = field(default_factory=list)

    def add_error(self, error: SyncError) -> None:
        self.errors.append(error)
        self.ok = False


def load_ssot(project_root: Path) -> dict:
    ssot_path = project_root / SSOT_PATH
    try:
        return json.loads(ssot_path.read_text(encoding="utf-8"))
    except FileNotFoundError:
        raise FileNotFoundError(f"SSOT 配置不存在: {ssot_path}") from None
    except json.JSONDecodeError as exc:
        raise ValueError(f"SSOT 配置 JSON 解析失败: {ssot_path}: {exc}") from exc


def render_snippet(ssot: dict) -> str:
    if "mcpServers" not in ssot:
        raise ValueError("SSOT 配置缺少 mcpServers 字段")
    snippet = {"mcpServers": ssot["mcpServers"]}
    return json.dumps(snippet, indent=2, ensure_ascii=False)


def build_block(snippet: str) -> str:
    return "\n".join(
        [
            BEGIN_MARKER,
            AUTO_COMMENT,
            "",
            "```json",
            snippet,
            "```",
            END_MARKER,
        ]
    )


def extract_generated_block(content: str) -> str | None:
    start = content.find(BEGIN_MARKER)
    end = content.find(END_MARKER)
    if start == -1 and end == -1:
        return None
    if start == -1 or end == -1 or end <= start:
        raise ValueError("受控块标记不完整或顺序错误")
    end = end + len(END_MARKER)
    return content[start:end].strip()


def check_controlled_block(
    doc_path: Path, content: str, expected_block: str, result: SyncResult
) -> None:
    try:
        block = extract_generated_block(content)
    except ValueError as exc:
        result.add_error(
            SyncError(
                code="doc_mcp_block_marker_invalid",
                message=str(exc),
                file=str(doc_path),
                hint="请添加完整的受控块标记",
            )
        )
        return

    if block is None:
        result.add_error(
            SyncError(
                code="doc_mcp_block_missing",
                message="未找到 mcp_config_snippet 受控块",
                file=str(doc_path),
                hint="运行 make update-mcp-config-docs 生成受控块",
            )
        )
        return

    if block.strip() != expected_block.strip():
        result.add_error(
            SyncError(
                code="doc_mcp_block_drift",
                message="受控块内容与 SSOT 不一致",
                file=str(doc_path),
                hint="运行 make update-mcp-config-docs 同步内容",
            )
        )


def contains_mcp_servers_block(content: str) -> bool:
    for match in CODE_FENCE_PATTERN.finditer(content):
        if "mcpServers" in match.group(1):
            return True
    return False


def check_forbidden_blocks(project_root: Path, result: SyncResult) -> None:
    allowset = {str((project_root / path).resolve()) for path in DOC_ALLOWLIST}
    for doc_path in project_root.rglob("*.md"):
        if ".git" in doc_path.parts:
            continue
        resolved = str(doc_path.resolve())
        if resolved in allowset:
            continue
        content = doc_path.read_text(encoding="utf-8")
        if contains_mcp_servers_block(content):
            result.add_error(
                SyncError(
                    code="doc_mcp_block_forbidden",
                    message="非白名单文档包含 mcpServers 代码块",
                    file=str(doc_path),
                    hint="移除该代码块并链接到 README 或 docs/installation.md 或 docs/gateway/02_mcp_integration_cursor.md",
                )
            )


def check_gateway_server_examples(doc_path: Path, content: str, result: SyncResult) -> None:
    if not DEFAULT_SERVER_PATTERN.search(content):
        result.add_error(
            SyncError(
                code="doc_mcp_default_server_missing",
                message="未找到默认 server 声明",
                file=str(doc_path),
                hint=f"请添加默认 server 声明并设为 {DEFAULT_SERVER_NAME}",
            )
        )
    if not SERVER_EXAMPLE_PATTERN.search(content):
        result.add_error(
            SyncError(
                code="doc_mcp_server_example_missing",
                message="未找到 --server 示例命令",
                file=str(doc_path),
                hint=f"请提供包含 --server {DEFAULT_SERVER_NAME} 的示例命令",
            )
        )


def format_text_output(result: SyncResult) -> str:
    lines = [
        "=" * 64,
        "MCP Config Docs Sync Check",
        "=" * 64,
        "",
        f"Checked docs: {len(result.checked_docs)}",
        f"Errors: {len(result.errors)}",
    ]
    if result.errors:
        lines.append("")
        lines.append("ERRORS:")
        for error in result.errors:
            lines.append(f"  [{error.code}] {error.file}")
            lines.append(f"    {error.message}")
            if error.hint:
                lines.append(f"    Fix: {error.hint}")
    return "\n".join(lines)


def format_json_output(result: SyncResult) -> str:
    payload = {
        "ok": result.ok,
        "checked_docs": result.checked_docs,
        "error_count": len(result.errors),
        "errors": [
            {
                "code": e.code,
                "message": e.message,
                "file": e.file,
                "hint": e.hint,
            }
            for e in result.errors
        ],
    }
    return json.dumps(payload, indent=2, ensure_ascii=False)


def main() -> int:
    parser = argparse.ArgumentParser(description="检查 MCP 配置文档与 SSOT 同步一致性")
    parser.add_argument(
        "--json",
        action="store_true",
        help="JSON 格式输出",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="显示详细信息",
    )
    parser.add_argument(
        "--project-root",
        type=Path,
        default=None,
        help="项目根目录（默认自动检测）",
    )
    args = parser.parse_args()

    project_root = args.project_root or Path(__file__).resolve().parent.parent.parent
    result = SyncResult()

    ssot = load_ssot(project_root)
    snippet = render_snippet(ssot)
    expected_block = build_block(snippet)

    for doc in DOC_ALLOWLIST:
        doc_path = project_root / doc
        if not doc_path.exists():
            result.add_error(
                SyncError(
                    code="doc_missing",
                    message="白名单文档不存在",
                    file=str(doc_path),
                )
            )
            continue
        content = doc_path.read_text(encoding="utf-8")
        result.checked_docs.append(str(doc))
        check_controlled_block(doc_path, content, expected_block, result)

        if doc == Path("docs/gateway/02_mcp_integration_cursor.md"):
            check_gateway_server_examples(doc_path, content, result)

    check_forbidden_blocks(project_root, result)

    if args.json:
        print(format_json_output(result))
    else:
        if args.verbose:
            print(f"Project root: {project_root}")
            print("")
        print(format_text_output(result))

    return 0 if result.ok else 1


if __name__ == "__main__":
    try:
        sys.exit(main())
    except (FileNotFoundError, ValueError) as exc:
        print(f"[ERROR] {exc}", file=sys.stderr)
        sys.exit(2)
