#!/usr/bin/env python3
"""从 evidence JSON 渲染验收证据 Markdown 片段。

用法:
    python scripts/iteration/render_iteration_evidence_snippet.py <iteration_number>

示例:
    # 渲染 Iteration 13 的验收证据片段
    python scripts/iteration/render_iteration_evidence_snippet.py 13

功能:
    1. 读取 docs/acceptance/evidence/iteration_<N>_evidence.json
    2. 解析 JSON 并提取关键字段
    3. 输出固定结构的 Markdown 片段:
       - ## 验收证据
       - 元信息表格（证据文件/Schema/记录时间/Commit）
       - 门禁命令执行摘要表（从 commands 数组渲染）
       - 整体验收结果

校验:
    - 输入文件必须存在
    - JSON 必须可解析
    - 必要字段必须存在（iteration_number, recorded_at, commit_sha, commands）
"""

from __future__ import annotations

import argparse
import json
import re
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any, List, Literal, Optional

REPO_ROOT = Path(__file__).resolve().parent.parent.parent
SRC_DIR = REPO_ROOT / "src"
if SRC_DIR.exists() and str(SRC_DIR) not in sys.path:
    sys.path.insert(0, str(SRC_DIR))
SCRIPT_DIR = Path(__file__).resolve().parent
if str(SCRIPT_DIR) not in sys.path:
    sys.path.insert(0, str(SCRIPT_DIR))

from engram.common.redaction import redact_sensitive_text
from generated_blocks import (  # noqa: E402
    generate_evidence_block_with_markers,
    render_evidence_snippet as render_evidence_snippet_v2,
)
from iteration_evidence_schema import (
    CURRENT_SCHEMA_FILENAME,
    resolve_schema_name,
)
# 默认路径配置
DEFAULT_EVIDENCE_DIR = Path("docs/acceptance/evidence")

# 兼容旧测试/调用方的默认 schema 常量
SCHEMA_NAME = CURRENT_SCHEMA_FILENAME

# 自动生成标识行（机器可识别）
AUTO_GENERATED_MARKER = "<!-- AUTO-GENERATED BY render_iteration_evidence_snippet.py -->"
BLOCK_START_MARKER = "<!-- AUTO-GENERATED EVIDENCE BLOCK START -->"
BLOCK_END_MARKER = "<!-- AUTO-GENERATED EVIDENCE BLOCK END -->"
NEW_BLOCK_START_MARKER = "<!-- BEGIN GENERATED: evidence_snippet -->"
NEW_BLOCK_END_MARKER = "<!-- END GENERATED: evidence_snippet -->"

MarkerStyle = Literal["none", "with_markers", "legacy_markers"]


@dataclass
class CommandEntry:
    """单个门禁命令的执行记录。"""

    name: str
    command: str
    result: str
    summary: Optional[str] = None
    duration_seconds: Optional[float] = None
    exit_code: Optional[int] = None


@dataclass
class EvidenceData:
    """验收证据数据。"""

    iteration_number: int
    recorded_at: str
    commit_sha: str
    commands: List[CommandEntry]
    schema_name: str = SCHEMA_NAME
    schema_value: Optional[str] = None
    overall_result: Optional[str] = None
    notes: Optional[str] = None
    links: Optional[dict[str, Any]] = None


class EvidenceParseError(Exception):
    """证据解析错误。"""

    pass


def parse_command_entry(data: dict[str, Any]) -> CommandEntry:
    """解析单个命令条目。

    Args:
        data: 命令数据字典

    Returns:
        CommandEntry 对象

    Raises:
        EvidenceParseError: 缺少必要字段时抛出
    """
    required_fields = ["name", "command", "result"]
    for field in required_fields:
        if field not in data:
            raise EvidenceParseError(f"命令条目缺少必要字段: {field}")

    return CommandEntry(
        name=data["name"],
        command=data["command"],
        result=data["result"],
        summary=data.get("summary"),
        duration_seconds=data.get("duration_seconds"),
        exit_code=data.get("exit_code"),
    )


def parse_evidence_data(data: dict[str, Any]) -> EvidenceData:
    """解析证据数据。

    Args:
        data: JSON 数据字典

    Returns:
        EvidenceData 对象

    Raises:
        EvidenceParseError: 缺少必要字段或格式错误时抛出
    """
    schema_name = resolve_schema_name(
        data.get("$schema") if isinstance(data.get("$schema"), str) else None
    )
    required_fields = ["iteration_number", "recorded_at", "commit_sha", "commands"]
    for field in required_fields:
        if field not in data:
            raise EvidenceParseError(
                f"证据文件缺少必要字段: {field}\n"
                f"必要字段: {', '.join(required_fields)}\n"
                f"请检查证据文件格式是否符合 schemas/{schema_name}"
                f"（当前: {CURRENT_SCHEMA_FILENAME}）"
            )

    commands_data = data["commands"]
    if not isinstance(commands_data, list):
        raise EvidenceParseError("commands 字段必须是数组")
    if len(commands_data) == 0:
        raise EvidenceParseError("commands 数组不能为空")

    commands = [parse_command_entry(cmd) for cmd in commands_data]

    return EvidenceData(
        schema_name=schema_name,
        iteration_number=data["iteration_number"],
        recorded_at=data["recorded_at"],
        commit_sha=data["commit_sha"],
        commands=commands,
        overall_result=data.get("overall_result"),
        notes=data.get("notes"),
    )


def load_evidence_file(evidence_path: Path) -> EvidenceData:
    """加载并解析证据文件。

    Args:
        evidence_path: 证据文件路径

    Returns:
        EvidenceData 对象

    Raises:
        EvidenceParseError: 文件不存在、无法解析或格式错误时抛出
    """
    if not evidence_path.exists():
        raise EvidenceParseError(
            f"证据文件不存在: {evidence_path}\n"
            f"请先运行 record_iteration_evidence.py 生成证据文件"
        )

    try:
        with open(evidence_path, encoding="utf-8") as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        raise EvidenceParseError(
            f"证据文件 JSON 解析失败: {evidence_path}\n"
            f"错误详情: {e}\n"
            f"请检查文件是否为有效的 JSON 格式"
        ) from e

    return parse_evidence_data(data)


def format_duration(seconds: Optional[float]) -> str:
    """格式化耗时。

    Args:
        seconds: 秒数

    Returns:
        格式化的耗时字符串
    """
    if seconds is None:
        return "-"
    if seconds < 60:
        return f"{seconds:.1f}s"
    minutes = int(seconds // 60)
    remaining_seconds = seconds % 60
    return f"{minutes}m{remaining_seconds:.0f}s"


def render_meta_table(evidence: EvidenceData, evidence_filename: str) -> str:
    """渲染元信息表格。

    Args:
        evidence: 证据数据
        evidence_filename: 证据文件名

    Returns:
        Markdown 表格字符串
    """
    lines = [
        "| 项目 | 值 |",
        "|------|-----|",
        f"| **证据文件** | [`{evidence_filename}`](evidence/{evidence_filename}) |",
        f"| **Schema 版本** | `{evidence.schema_name}` |",
        f"| **记录时间** | {evidence.recorded_at} |",
        f"| **Commit SHA** | `{evidence.commit_sha[:7]}` |",
    ]
    return "\n".join(lines)


def render_commands_table(commands: List[CommandEntry]) -> str:
    """渲染门禁命令执行摘要表。

    Args:
        commands: 命令列表

    Returns:
        Markdown 表格字符串
    """
    lines = [
        "| 命令 | 结果 | 耗时 | 摘要 |",
        "|------|------|------|------|",
    ]

    for cmd in commands:
        duration = format_duration(cmd.duration_seconds)
        safe_command = redact_sensitive_text(cmd.command)
        summary = cmd.summary if cmd.summary else "-"
        summary = redact_sensitive_text(summary)
        # 截断过长的摘要
        if len(summary) > 50:
            summary = summary[:47] + "..."
        lines.append(f"| `{safe_command}` | {cmd.result} | {duration} | {summary} |")

    return "\n".join(lines)


def render_overall_result(evidence: EvidenceData) -> str:
    """渲染整体验收结果。

    Args:
        evidence: 证据数据

    Returns:
        Markdown 字符串
    """
    result = evidence.overall_result if evidence.overall_result else "未指定"
    lines = [
        f"- **结果**: {result}",
    ]

    if evidence.notes:
        # 截断过长的说明
        notes = redact_sensitive_text(evidence.notes)
        if len(notes) > 200:
            notes = notes[:197] + "..."
        lines.append(f"- **说明**: {notes}")

    return "\n".join(lines)


def render_evidence_snippet(
    evidence: EvidenceData,
    evidence_filename: str,
) -> str:
    """渲染完整的验收证据 Markdown 片段。

    Args:
        evidence: 证据数据
        evidence_filename: 证据文件名

    Returns:
        完整的 Markdown 内容
    """
    sections = [
        "## 验收证据",
        "",
        BLOCK_START_MARKER,
        AUTO_GENERATED_MARKER,
        "",
        render_meta_table(evidence, evidence_filename),
        "",
        "### 门禁命令执行摘要",
        "",
        "> 以下表格由脚本从 `evidence/*.json` 的 `commands` 数组自动渲染。",
        "",
        render_commands_table(evidence.commands),
        "",
        "### 整体验收结果",
        "",
        render_overall_result(evidence),
        "",
        BLOCK_END_MARKER,
        "",
    ]

    return "\n".join(sections)


def get_evidence_path(iteration_number: int, base_dir: Optional[Path] = None) -> Path:
    """获取证据文件路径。

    Args:
        iteration_number: 迭代编号
        base_dir: 基础目录（默认使用 DEFAULT_EVIDENCE_DIR）

    Returns:
        证据文件路径
    """
    if base_dir is None:
        base_dir = DEFAULT_EVIDENCE_DIR
    return base_dir / f"iteration_{iteration_number}_evidence.json"


def render_iteration_evidence_snippet(
    iteration_number: int,
    evidence_dir: Optional[Path] = None,
) -> str:
    """渲染指定迭代的验收证据片段。

    这是主要的公开 API 函数。

    Args:
        iteration_number: 迭代编号
        evidence_dir: 证据目录（默认使用 DEFAULT_EVIDENCE_DIR）

    Returns:
        完整的 Markdown 内容

    Raises:
        EvidenceParseError: 文件不存在、无法解析或格式错误时抛出
    """
    evidence_path = get_evidence_path(iteration_number, evidence_dir)
    evidence_filename = evidence_path.name

    evidence = load_evidence_file(evidence_path)
    return render_evidence_snippet(evidence, evidence_filename)


# ============================================================================
# CLI 入口
# ============================================================================


def main() -> int:
    """主函数。"""
    parser = argparse.ArgumentParser(
        description="从 evidence JSON 渲染验收证据 Markdown 片段",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
示例:
    # 渲染 Iteration 13 的验收证据片段
    python scripts/iteration/render_iteration_evidence_snippet.py 13

    # 输出会直接打印到标准输出，可重定向到文件
    python scripts/iteration/render_iteration_evidence_snippet.py 13 > evidence_snippet.md

证据文件位置:
    docs/acceptance/evidence/iteration_<N>_evidence.json

输出结构:
    ## 验收证据
    - 元信息表格（证据文件/Schema/记录时间/Commit）
    - 门禁命令执行摘要表
    - 整体验收结果
        """,
    )
    parser.add_argument(
        "iteration_number",
        type=int,
        help="迭代编号",
    )
    parser.add_argument(
        "--evidence-dir",
        type=Path,
        default=None,
        help=f"证据目录路径（默认: {DEFAULT_EVIDENCE_DIR}）",
    )

    args = parser.parse_args()

    try:
        output = render_iteration_evidence_snippet(
            args.iteration_number,
            args.evidence_dir,
        )
        print(output)
        return 0
    except EvidenceParseError as e:
        print(f"错误: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
