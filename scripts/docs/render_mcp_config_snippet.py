#!/usr/bin/env python3
"""
渲染 MCP 配置片段（基于 SSOT）并更新文档受控块。

默认行为：输出渲染后的 JSON 片段到 stdout。
--write：将受控块写入到白名单文档。

受控块标记:
    <!-- BEGIN GENERATED: mcp_config_snippet -->
    <!-- AUTO-GENERATED BY render_mcp_config_snippet.py; DO NOT EDIT -->
    ```json
    ...
    ```
    <!-- END GENERATED -->
"""

from __future__ import annotations

import argparse
import json
import re
import sys
from pathlib import Path

SSOT_PATH = Path("configs/mcp/.mcp.json.example")
DOC_PATHS = [
    Path("README.md"),
    Path("docs/installation.md"),
    Path("docs/gateway/02_mcp_integration_cursor.md"),
]

BEGIN_MARKER = "<!-- BEGIN GENERATED: mcp_config_snippet -->"
END_MARKER = "<!-- END GENERATED -->"
AUTO_COMMENT = "<!-- AUTO-GENERATED BY render_mcp_config_snippet.py; DO NOT EDIT -->"


def load_ssot(project_root: Path) -> dict:
    ssot_path = project_root / SSOT_PATH
    try:
        return json.loads(ssot_path.read_text(encoding="utf-8"))
    except FileNotFoundError:
        raise FileNotFoundError(f"SSOT 配置不存在: {ssot_path}") from None
    except json.JSONDecodeError as exc:
        raise ValueError(f"SSOT 配置 JSON 解析失败: {ssot_path}: {exc}") from exc


def render_snippet(ssot: dict) -> str:
    if "mcpServers" not in ssot:
        raise ValueError("SSOT 配置缺少 mcpServers 字段")
    snippet = {"mcpServers": ssot["mcpServers"]}
    return json.dumps(snippet, indent=2, ensure_ascii=False)


def build_block(snippet: str) -> str:
    return "\n".join(
        [
            BEGIN_MARKER,
            AUTO_COMMENT,
            "",
            "```json",
            snippet,
            "```",
            END_MARKER,
        ]
    )


def replace_block(content: str, block: str) -> str:
    if BEGIN_MARKER not in content or END_MARKER not in content:
        raise ValueError("未找到 mcp_config_snippet 受控块标记")

    pattern = re.compile(
        re.escape(BEGIN_MARKER) + r".*?" + re.escape(END_MARKER),
        re.DOTALL,
    )
    return pattern.sub(block, content, count=1)


def update_docs(project_root: Path, block: str, doc_paths: list[Path]) -> list[str]:
    updated: list[str] = []
    for doc_path in doc_paths:
        path = project_root / doc_path
        if not path.exists():
            raise FileNotFoundError(f"文档不存在: {path}")

        content = path.read_text(encoding="utf-8")
        new_content = replace_block(content, block)
        if new_content != content:
            path.write_text(new_content, encoding="utf-8")
            updated.append(str(doc_path))
    return updated


def main() -> int:
    parser = argparse.ArgumentParser(description="渲染 MCP 配置片段并更新文档受控块")
    parser.add_argument(
        "--write",
        action="store_true",
        help="写入白名单文档受控块（默认仅输出片段）",
    )
    parser.add_argument(
        "--project-root",
        type=Path,
        default=None,
        help="项目根目录（默认自动检测）",
    )
    parser.add_argument(
        "--docs",
        nargs="*",
        default=None,
        help="指定要写入的文档路径（相对于项目根目录）",
    )

    args = parser.parse_args()

    project_root = args.project_root or Path(__file__).resolve().parent.parent.parent
    ssot = load_ssot(project_root)
    snippet = render_snippet(ssot)

    if not args.write:
        print(snippet)
        return 0

    doc_paths = [Path(p) for p in args.docs] if args.docs else DOC_PATHS
    block = build_block(snippet)
    updated = update_docs(project_root, block, doc_paths)

    if updated:
        print("已更新文档受控块:")
        for doc in updated:
            print(f"  - {doc}")
    else:
        print("文档受控块无需更新")

    return 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except (FileNotFoundError, ValueError) as exc:
        print(f"[ERROR] {exc}", file=sys.stderr)
        sys.exit(2)
